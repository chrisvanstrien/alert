<html>

<script src="spine-webgl.js"></script>

<style>
	* { margin: 0; padding: 0; }
	body, html { height: 100% background-color: rgba(0, 0, 0, 0);}
	canvas { position: absolute; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0);}
</style>

<body>
<canvas id="canvas"></canvas>
</body>

<script>

var lastFrameTime = Date.now() / 1000;
var canvas;
var shader;
var batcher;
var gl;
var mvp = new spine.webgl.Matrix4();
var assetManager;
var skeletonRenderer;
var mainSkeleton;
var randomSlots;

function init() {
	canvas = document.getElementById("canvas");
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	var config = { alpha: true };
	gl = canvas.getContext("webgl", config) || canvas.getContext("experimental-webgl", config);
	
	if (!gl) { console.log("WebGL is required and not supported."); return; }

	shader = spine.webgl.Shader.newTwoColoredTextured(gl);
	batcher = new spine.webgl.PolygonBatcher(gl);
	mvp.ortho2d(0, 0, canvas.width - 1, canvas.height - 1);
	skeletonRenderer = new spine.webgl.SkeletonRenderer(gl);
	assetManager = new spine.webgl.AssetManager(gl);

	assetManager.loadText("/alert/shiba.json");
	assetManager.loadTextureAtlas("/alert/shiba.atlas");
	
	requestAnimationFrame(load);
}

function load() {
	if (assetManager.isLoadingComplete()) {
		mainSkeleton = loadSkeleton("animation");
		
		randomizeColors();
		storeRandomizeSlots();
		applyRandomizedSlots();
		closeEyesAndMouth();
		
		requestAnimationFrame(render);
	} else {
		requestAnimationFrame(load);
	}
}

function loadSkeleton(initialAnimation, skin) {
	if (skin === undefined) skin = "default";

	var atlas = assetManager.get("/alert/shiba.atlas");
	var atlasLoader = new spine.AtlasAttachmentLoader(atlas);
	var skeletonJson = new spine.SkeletonJson(atlasLoader);
	var skeletonData = skeletonJson.readSkeletonData(assetManager.get("/alert/shiba.json"));
	var skeleton = new spine.Skeleton(skeletonData);
	
	skeleton.setSkinByName(skin);
	
	var bounds = calculateBounds(skeleton);

	var animationStateData = new spine.AnimationStateData(skeleton.data);
	var animationState = new spine.AnimationState(animationStateData);
	animationState.setAnimation(0, initialAnimation, true); // true is loop

	animationState.addListener({
		start: function(track) {},
		interrupt: function(track) {},
		end: function(track) {},
		disposed: function(track) {},
		complete: function(track) {
			randomizeColors();
			storeRandomizeSlots();
			applyRandomizedSlots();
			closeEyesAndMouth();
		},
		event: function(track, event) {
			animationEvent(event.name);
		}
	})
			
	return { skeleton: skeleton, state: animationState, bounds: bounds};
}

// call applyRandomizedSlots?
function animationEvent(name) { // "still" is actually just whenever the dogs eyes open
	// have a dict for slots listing all the possible options, in rise still sets, including [null, null] if applicable 
	// take one of those for each key and move it to generated one, the currently selected rng combo
	// or can store an index into the dict of all possible, but thats a lot of indices to have

	// check if its rising start, standing start
	
	// {slotName: [attachmentNameRise, attachmentNameStill]}
			
	// iterate KEYs in this DICT:
	// skeleton.findSlot("KEY").setAttachment(DICT[KEY][name == RISING ? 0 : 1]) //just set attachment with first arg slot name?
	
	applyRandomizedSlots();
}

function storeRandomizeSlots() {
	var bandana = true;
	var bandanaType = "dots";
	
	var blush = true;
	
	var eyeType = "glow";
	
	var mouthOpen = true;
	var leftFang = true;
	var rightFang = true
	var tounge = true;
	
	var collar = false;
	
	var cowlick = false;
	
	var leaf = true;
	
	var tuff = true;
	
	var browType = "soft";

	randomSlots = {
		"bandana color": bandana,
		"bandana outline": bandana,
		"bandana dots": bandana && bandanaType === "dots",
		"bandana stripes": bandana && bandanaType === "stripes",
		
		"blush": blush,
		
		"close eyes color": eyeType === "close",
		"evil eyes color": eyeType === "evil",
		"normal eyes color": eyeType === "normal" || eyeType === "glow",
		"normal eyes glare": eyeType === "normal",
		"normal eyes glow": eyeType === "glow",
		
		"closed mouth left fang": !mouthOpen && leftFang,
		"closed mouth outline": !mouthOpen,
		"closed mouth right fang": !mouthOpen && rightFang,
		"closed mouth tounge": !mouthOpen && tounge,
		"open mouth color": mouthOpen,
		"open mouth left fang": mouthOpen && leftFang,
		"open mouth outline": mouthOpen,
		"open mouth right fang": mouthOpen && rightFang,
		"open mouth tounge": mouthOpen && tounge,
		
		"collar color": collar,
		"collar outline": collar,
		"tag color": collar,
		"tag outline": collar,
		
		"cowlick color": cowlick,
		"cowlick outline": cowlick,
		
		"leaf color": leaf,
		"leaf outline": leaf,
		
		"normal brows": browType === "normal",
		"soft brows": browType === "soft",
		
		"tuff color": tuff,
		"tuff outline": tuff
	}
}

function applyRandomizedSlots() {
	Object.keys(randomSlots).forEach(function(key) {
		console.log(key +""+ randomSlots[key]);
		slotOn(key, randomSlots[key]);
	});
}

function closeEyesAndMouth() {
	slotOn("evil eyes color", false);
	slotOn("normal eyes color", false);
	slotOn("normal eyes glare", false);
	slotOn("normal eyes glow", false);
	
	slotOn("close eyes color", true);
	
	
	slotOn("open mouth tounge", false);
	slotOn("open mouth outline", false);
	slotOn("open mouth right fang", false);
	slotOn("open mouth left fang", false);
	slotOn("open mouth color", false);

	slotOn("closed mouth outline", true);
}

function randomizeColors() { // set nose patch visibility here, randomize non-fur
	var furPalettes = [
		{primary:{r:244/255, g:198/255, b:120/255, a:1}, secondary:{r:248/255, g:241/255, b:231/255, a:1}},
		{primary:{r:133/255, g:84/255, b:80/255, a:1}, secondary:{r:248/255, g:241/255, b:231/255, a:1}},
		{primary:{r:206/255, g:217/255, b:225/255, a:1}, secondary:{r:248/255, g:248/255, b:248/255, a:1}},
		{primary:{r:231/255, g:180/255, b:228/255, a:1}, secondary:{r:248/255, g:248/255, b:248/255, a:1}}
	];
	
	var furSlots = {
		primary: [
			"cowlick color",
			"tuff color",
			"left down hand dark",
			"right down hand dark",
			"left up hand dark",
			"right up hand dark",
			"color arms",
			"color head",
			"tail dark"
		],
		secondary: [
			"color jaw",
			"color ear",
			"tail light",
			"normal brows",
			"soft brows",
			"left down hand light",
			"right down hand light",
			"left up hand light",
			"right up hand light"
		]
	}
	
	var furPaletteIndex = Math.floor(Math.random() * 4); 
	
	furSlots.primary.forEach(function(element) {
		mainSkeleton.skeleton.findSlot(element).color = furPalettes[furPaletteIndex].primary;
	});
	
	furSlots.secondary.forEach(function(element) {
		mainSkeleton.skeleton.findSlot(element).color = furPalettes[furPaletteIndex].secondary;
	});
	
	// call on animation start
}

function slotOn(slot, on) {
	mainSkeleton.skeleton.findSlot(slot).setAttachment(on == true ? slot : null);
}

function calculateBounds(skeleton) {
	skeleton.setToSetupPose();
	skeleton.updateWorldTransform();
	var offset = new spine.Vector2();
	var size = new spine.Vector2();
	skeleton.getBounds(offset, size, []);
	return { offset: offset, size: size };
}

function render() {
	var now = Date.now() / 1000;
	var delta = now - lastFrameTime;
	lastFrameTime = now;

	resize();

	gl.clearColor(0, 0, 0, 0); // clear to transparent
	gl.clear(gl.COLOR_BUFFER_BIT);

	var state = mainSkeleton.state;
	var skeleton = mainSkeleton.skeleton;
	var bounds = mainSkeleton.bounds;
	
	state.update(delta);
	state.apply(skeleton);
	skeleton.updateWorldTransform();

	shader.bind();
		shader.setUniformi(spine.webgl.Shader.SAMPLER, 0);
		shader.setUniform4x4f(spine.webgl.Shader.MVP_MATRIX, mvp.values);

		batcher.begin(shader);
			skeletonRenderer.vertexEffect = null; // not needed?
			skeletonRenderer.premultipliedAlpha = true;
			skeletonRenderer.draw(batcher, skeleton);
		batcher.end();
	shader.unbind();

	requestAnimationFrame(render);
}

function resize() {
	var w = canvas.clientWidth;
	var h = canvas.clientHeight;
	var bounds = mainSkeleton.bounds;
	if (canvas.width != w || canvas.height != h) {
		canvas.width = w;
		canvas.height = h;
	}

	var centerX = bounds.offset.x + bounds.size.x / 2;
	var centerY = bounds.offset.y + bounds.size.y / 2;
	var scaleX = bounds.size.x / canvas.width;
	var scaleY = bounds.size.y / canvas.height;
	var scale = Math.max(scaleX, scaleY) * 1.2;
	if (scale < 1) scale = 1;
	var width = canvas.width * scale;
	var height = canvas.height * scale;

	mvp.ortho2d(centerX - width / 2, centerY - height / 2, width, height);
	gl.viewport(0, 0, canvas.width, canvas.height);
}

init();

</script>

</html>